#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxBackdrop
#include <flixel/addons/display/FlxBackdrop.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxGridOverlay
#include <flixel/addons/display/FlxGridOverlay.h>
#endif
#ifndef INCLUDED_flixel_addons_display_shapes_FlxShape
#include <flixel/addons/display/shapes/FlxShape.h>
#endif
#ifndef INCLUDED_flixel_addons_display_shapes_FlxShapeCircle
#include <flixel/addons/display/shapes/FlxShapeCircle.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_FlxUIState
#include <flixel/addons/ui/FlxUIState.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IEventGetter
#include <flixel/addons/ui/interfaces/IEventGetter.h>
#endif
#ifndef INCLUDED_flixel_addons_ui_interfaces_IFlxUIState
#include <flixel/addons/ui/interfaces/IFlxUIState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadAnalogStick
#include <flixel/input/gamepad/FlxGamepadAnalogStick.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxGradient
#include <flixel/util/FlxGradient.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_lime_system_Clipboard
#include <lime/system/Clipboard.h>
#endif
#ifndef INCLUDED_objects_Alignment
#include <objects/Alignment.h>
#endif
#ifndef INCLUDED_objects_AlphaCharacter
#include <objects/AlphaCharacter.h>
#endif
#ifndef INCLUDED_objects_Alphabet
#include <objects/Alphabet.h>
#endif
#ifndef INCLUDED_objects_Note
#include <objects/Note.h>
#endif
#ifndef INCLUDED_objects_StrumNote
#include <objects/StrumNote.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_options_NotesSubState
#include <options/NotesSubState.h>
#endif
#ifndef INCLUDED_shaders_RGBPalette
#include <shaders/RGBPalette.h>
#endif
#ifndef INCLUDED_shaders_RGBPaletteShader
#include <shaders/RGBPaletteShader.h>
#endif
#ifndef INCLUDED_shaders_RGBShaderReference
#include <shaders/RGBShaderReference.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_13db6fe15635f7e3_17_new,"options.NotesSubState","new",0xf0ea0e94,"options.NotesSubState.new","options/NotesSubState.hx",17,0x2831b15d)
static const int _hx_array_data_0afa74a2_1[] = {
	(int)-1,(int)-16777216,
};
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_170_updateTip,"options.NotesSubState","updateTip",0xad1a1c06,"options.NotesSubState.updateTip","options/NotesSubState.hx",170,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_181_update,"options.NotesSubState","update",0xb5c92055,"options.NotesSubState.update","options/NotesSubState.hx",181,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_368_update,"options.NotesSubState","update",0xb5c92055,"options.NotesSubState.update","options/NotesSubState.hx",368,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_381_update,"options.NotesSubState","update",0xb5c92055,"options.NotesSubState.update","options/NotesSubState.hx",381,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_493_pointerOverlaps,"options.NotesSubState","pointerOverlaps",0x070d911d,"options.NotesSubState.pointerOverlaps","options/NotesSubState.hx",493,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_499_pointerX,"options.NotesSubState","pointerX",0xc6feaa47,"options.NotesSubState.pointerX","options/NotesSubState.hx",499,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_504_pointerY,"options.NotesSubState","pointerY",0xc6feaa48,"options.NotesSubState.pointerY","options/NotesSubState.hx",504,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_509_pointerFlxPoint,"options.NotesSubState","pointerFlxPoint",0x6b9ac08f,"options.NotesSubState.pointerFlxPoint","options/NotesSubState.hx",509,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_515_centerHexTypeLine,"options.NotesSubState","centerHexTypeLine",0x8b4ee728,"options.NotesSubState.centerHexTypeLine","options/NotesSubState.hx",515,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_531_changeSelectionMode,"options.NotesSubState","changeSelectionMode",0x44e98c73,"options.NotesSubState.changeSelectionMode","options/NotesSubState.hx",531,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_543_changeSelectionNote,"options.NotesSubState","changeSelectionNote",0x4592d102,"options.NotesSubState.changeSelectionNote","options/NotesSubState.hx",543,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_560_makeColorAlphabet,"options.NotesSubState","makeColorAlphabet",0x796c6f9c,"options.NotesSubState.makeColorAlphabet","options/NotesSubState.hx",560,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_579_spawnNotes,"options.NotesSubState","spawnNotes",0x9defe852,"options.NotesSubState.spawnNotes","options/NotesSubState.hx",579,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_583_spawnNotes,"options.NotesSubState","spawnNotes",0x9defe852,"options.NotesSubState.spawnNotes","options/NotesSubState.hx",583,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_574_spawnNotes,"options.NotesSubState","spawnNotes",0x9defe852,"options.NotesSubState.spawnNotes","options/NotesSubState.hx",574,0x2831b15d)
static const int _hx_array_data_0afa74a2_21[] = {
	(int)0,
};
static const int _hx_array_data_0afa74a2_22[] = {
	(int)0,
};
static const int _hx_array_data_0afa74a2_23[] = {
	(int)1,
};
static const int _hx_array_data_0afa74a2_24[] = {
	(int)2,
};
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_655_updateNotes,"options.NotesSubState","updateNotes",0x4c70d7ac,"options.NotesSubState.updateNotes","options/NotesSubState.hx",655,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_671_updateColors,"options.NotesSubState","updateColors",0x2b1cc7e5,"options.NotesSubState.updateColors","options/NotesSubState.hx",671,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_702_setShaderColor,"options.NotesSubState","setShaderColor",0xcbe01dc8,"options.NotesSubState.setShaderColor","options/NotesSubState.hx",702,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_703_getShaderColor,"options.NotesSubState","getShaderColor",0xabc03554,"options.NotesSubState.getShaderColor","options/NotesSubState.hx",703,0x2831b15d)
HX_LOCAL_STACK_FRAME(_hx_pos_13db6fe15635f7e3_704_getShader,"options.NotesSubState","getShader",0xc3ac258f,"options.NotesSubState.getShader","options/NotesSubState.hx",704,0x2831b15d)
namespace options{

void NotesSubState_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_17_new)
HXLINE( 176)		 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN( 176)		_g->set(48,HX_("0",30,00,00,00));
HXDLIN( 176)		_g->set(49,HX_("1",31,00,00,00));
HXDLIN( 176)		_g->set(50,HX_("2",32,00,00,00));
HXDLIN( 176)		_g->set(51,HX_("3",33,00,00,00));
HXDLIN( 176)		_g->set(52,HX_("4",34,00,00,00));
HXDLIN( 176)		_g->set(53,HX_("5",35,00,00,00));
HXDLIN( 176)		_g->set(54,HX_("6",36,00,00,00));
HXDLIN( 176)		_g->set(55,HX_("7",37,00,00,00));
HXDLIN( 176)		_g->set(56,HX_("8",38,00,00,00));
HXDLIN( 176)		_g->set(57,HX_("9",39,00,00,00));
HXDLIN( 176)		_g->set(96,HX_("0",30,00,00,00));
HXDLIN( 176)		_g->set(97,HX_("1",31,00,00,00));
HXDLIN( 176)		_g->set(98,HX_("2",32,00,00,00));
HXDLIN( 176)		_g->set(99,HX_("3",33,00,00,00));
HXDLIN( 176)		_g->set(100,HX_("4",34,00,00,00));
HXDLIN( 176)		_g->set(101,HX_("5",35,00,00,00));
HXDLIN( 176)		_g->set(102,HX_("6",36,00,00,00));
HXDLIN( 176)		_g->set(103,HX_("7",37,00,00,00));
HXDLIN( 176)		_g->set(104,HX_("8",38,00,00,00));
HXDLIN( 176)		_g->set(105,HX_("9",39,00,00,00));
HXDLIN( 176)		_g->set(65,HX_("A",41,00,00,00));
HXDLIN( 176)		_g->set(66,HX_("B",42,00,00,00));
HXDLIN( 176)		_g->set(67,HX_("C",43,00,00,00));
HXDLIN( 176)		_g->set(68,HX_("D",44,00,00,00));
HXDLIN( 176)		_g->set(69,HX_("E",45,00,00,00));
HXDLIN( 176)		_g->set(70,HX_("F",46,00,00,00));
HXDLIN( 176)		this->allowedTypeKeys = _g;
HXLINE( 174)		this->changingNote = false;
HXLINE(  48)		this->_lastControllerMode = false;
HXLINE(  27)		this->hexTypeVisibleTimer = ((Float)0);
HXLINE(  26)		this->hexTypeNum = -1;
HXLINE(  22)		this->onPixel = false;
HXLINE(  21)		this->curSelectedNote = 0;
HXLINE(  20)		this->curSelectedMode = 0;
HXLINE(  19)		this->onModeColumn = true;
HXLINE(  52)		super::__construct();
HXLINE(  54)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  54)		 ::flixel::FlxSprite bg1 = bg->loadGraphic(::backend::Paths_obj::image(HX_("menuDesat",26,91,04,72),null(),null()),null(),null(),null(),null(),null());
HXLINE(  55)		bg1->set_color(-1412611);
HXLINE(  56)		{
HXLINE(  56)			int axes = 17;
HXDLIN(  56)			bool _hx_tmp;
HXDLIN(  56)			if ((axes != 1)) {
HXLINE(  56)				_hx_tmp = (axes == 17);
            			}
            			else {
HXLINE(  56)				_hx_tmp = true;
            			}
HXDLIN(  56)			if (_hx_tmp) {
HXLINE(  56)				int _hx_tmp = ::flixel::FlxG_obj::width;
HXDLIN(  56)				bg1->set_x(((( (Float)(_hx_tmp) ) - bg1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  56)			bool _hx_tmp1;
HXDLIN(  56)			if ((axes != 16)) {
HXLINE(  56)				_hx_tmp1 = (axes == 17);
            			}
            			else {
HXLINE(  56)				_hx_tmp1 = true;
            			}
HXDLIN(  56)			if (_hx_tmp1) {
HXLINE(  56)				int _hx_tmp = ::flixel::FlxG_obj::height;
HXDLIN(  56)				bg1->set_y(((( (Float)(_hx_tmp) ) - bg1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  57)		bg1->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  58)		this->add(bg1);
HXLINE(  60)		 ::flixel::addons::display::FlxBackdrop grid =  ::flixel::addons::display::FlxBackdrop_obj::__alloc( HX_CTX ,::flixel::addons::display::FlxGridOverlay_obj::createGrid(80,80,160,160,true,872415231,0),null(),null(),null(),null(),null(),null());
HXLINE(  61)		{
HXLINE(  61)			 ::flixel::math::FlxBasePoint this1 = grid->velocity;
HXDLIN(  61)			this1->set_x(( (Float)(40) ));
HXDLIN(  61)			this1->set_y(( (Float)(40) ));
            		}
HXLINE(  62)		grid->set_alpha(( (Float)(0) ));
HXLINE(  63)		::flixel::tweens::FlxTween_obj::tween(grid, ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("alpha",5e,a7,96,21),1)),((Float)0.5), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::quadOut_dyn())));
HXLINE(  64)		this->add(grid);
HXLINE(  66)		this->modeBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,215,85,null())->makeGraphic(315,115,-16777216,null(),null());
HXLINE(  67)		this->modeBG->set_visible(false);
HXLINE(  68)		this->modeBG->set_alpha(((Float)0.4));
HXLINE(  69)		this->add(this->modeBG);
HXLINE(  71)		this->notesBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,140,190,null())->makeGraphic(480,125,-16777216,null(),null());
HXLINE(  72)		this->notesBG->set_visible(false);
HXLINE(  73)		this->notesBG->set_alpha(((Float)0.4));
HXLINE(  74)		this->add(this->notesBG);
HXLINE(  76)		this->modeNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  77)		this->add(this->modeNotes);
HXLINE(  79)		this->myNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  80)		this->add(this->myNotes);
HXLINE(  82)		 ::flixel::FlxSprite bg2 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,720,null(),null());
HXDLIN(  82)		 ::flixel::FlxSprite bg3 = bg2->makeGraphic((::flixel::FlxG_obj::width - 720),::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE(  83)		bg3->set_alpha(((Float)0.25));
HXLINE(  84)		this->add(bg3);
HXLINE(  85)		 ::flixel::FlxSprite bg4 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,750,160,null());
HXDLIN(  85)		 ::flixel::FlxSprite bg5 = bg4->makeGraphic((::flixel::FlxG_obj::width - 780),540,-16777216,null(),null());
HXLINE(  86)		bg5->set_alpha(((Float)0.25));
HXLINE(  87)		this->add(bg5);
HXLINE(  89)		 ::objects::Alphabet text =  ::objects::Alphabet_obj::__alloc( HX_CTX ,( (Float)(50) ),( (Float)(86) ),HX_("CTRL",ab,50,89,2c),false);
HXLINE(  90)		text->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE(  91)		text->setScale(((Float)0.4),null());
HXLINE(  92)		this->add(text);
HXLINE(  94)		 ::flixel::FlxSprite _hx_tmp2 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,760,50,null());
HXDLIN(  94)		this->copyButton = _hx_tmp2->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/copy",14,93,08,23),null(),null()),null(),null(),null(),null(),null());
HXLINE(  95)		this->copyButton->set_alpha(((Float)0.6));
HXLINE(  96)		this->add(this->copyButton);
HXLINE(  98)		 ::flixel::FlxSprite _hx_tmp3 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,1180,50,null());
HXDLIN(  98)		this->pasteButton = _hx_tmp3->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/paste",14,ef,6e,f7),null(),null()),null(),null(),null(),null(),null());
HXLINE(  99)		this->pasteButton->set_alpha(((Float)0.6));
HXLINE( 100)		this->add(this->pasteButton);
HXLINE( 102)		this->colorGradient = ::flixel::util::FlxGradient_obj::createGradientFlxSprite(60,360,::Array_obj< int >::fromData( _hx_array_data_0afa74a2_1,2),null(),null(),null());
HXLINE( 103)		this->colorGradient->setPosition(780,200);
HXLINE( 104)		this->add(this->colorGradient);
HXLINE( 106)		this->colorGradientSelector =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,770,200,null())->makeGraphic(80,10,-1,null(),null());
HXLINE( 107)		this->colorGradientSelector->offset->set_y(( (Float)(5) ));
HXLINE( 108)		this->add(this->colorGradientSelector);
HXLINE( 110)		 ::flixel::FlxSprite _hx_tmp4 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,820,580,null());
HXDLIN( 110)		this->colorPalette = _hx_tmp4->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/palette",7c,60,ab,d2),null(),false),null(),null(),null(),null(),null());
HXLINE( 111)		{
HXLINE( 111)			 ::flixel::math::FlxBasePoint this2 = this->colorPalette->scale;
HXDLIN( 111)			this2->set_x(( (Float)(20) ));
HXDLIN( 111)			this2->set_y(( (Float)(20) ));
            		}
HXLINE( 112)		this->colorPalette->updateHitbox();
HXLINE( 113)		this->colorPalette->set_antialiasing(false);
HXLINE( 114)		this->add(this->colorPalette);
HXLINE( 116)		 ::flixel::FlxSprite _hx_tmp5 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,860,200,null());
HXDLIN( 116)		this->colorWheel = _hx_tmp5->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/colorWheel",d7,74,dc,98),null(),null()),null(),null(),null(),null(),null());
HXLINE( 117)		this->colorWheel->setGraphicSize(360,360);
HXLINE( 118)		this->colorWheel->updateHitbox();
HXLINE( 119)		this->add(this->colorWheel);
HXLINE( 121)		this->colorWheelSelector =  ::flixel::addons::display::shapes::FlxShapeCircle_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(8) ), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("thickness",74,f1,66,5a),0)),-1);
HXLINE( 122)		{
HXLINE( 122)			 ::flixel::math::FlxBasePoint this3 = this->colorWheelSelector->offset;
HXDLIN( 122)			this3->set_x(( (Float)(8) ));
HXDLIN( 122)			this3->set_y(( (Float)(8) ));
            		}
HXLINE( 123)		this->colorWheelSelector->set_alpha(((Float)0.6));
HXLINE( 124)		this->add(this->colorWheelSelector);
HXLINE( 126)		int txtX = 980;
HXLINE( 127)		int txtY = 90;
HXLINE( 128)		this->alphabetR = this->makeColorAlphabet((txtX - 100),txtY);
HXLINE( 129)		this->add(this->alphabetR);
HXLINE( 130)		this->alphabetG = this->makeColorAlphabet(txtX,txtY);
HXLINE( 131)		this->add(this->alphabetG);
HXLINE( 132)		this->alphabetB = this->makeColorAlphabet((txtX + 100),txtY);
HXLINE( 133)		this->add(this->alphabetB);
HXLINE( 134)		this->alphabetHex = this->makeColorAlphabet(txtX,(txtY - 55));
HXLINE( 135)		this->add(this->alphabetHex);
HXLINE( 136)		this->hexTypeLine =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,20,null())->makeGraphic(5,62,-1,null(),null());
HXLINE( 137)		this->hexTypeLine->set_visible(false);
HXLINE( 138)		this->add(this->hexTypeLine);
HXLINE( 140)		this->spawnNotes();
HXLINE( 141)		this->updateNotes(true);
HXLINE( 142)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp6 = ::flixel::FlxG_obj::sound;
HXDLIN( 142)		_hx_tmp6->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 144)		int tipX = 20;
HXLINE( 145)		int tipY = 660;
HXLINE( 146)		 ::flixel::text::FlxText tip =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,tipX,tipY,0,HX_("Press RELOAD to Reset the selected Note Part.",b7,56,2a,49),16,null());
HXLINE( 147)		::String file = ::backend::Paths_obj::modFolders((HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82)));
HXDLIN( 147)		::String _hx_tmp7;
HXDLIN( 147)		if (::sys::FileSystem_obj::exists(file)) {
HXLINE( 147)			_hx_tmp7 = file;
            		}
            		else {
HXLINE( 147)			_hx_tmp7 = (HX_("assets/fonts/",37,ff,a5,9c) + HX_("vcr.ttf",9d,d2,a7,82));
            		}
HXDLIN( 147)		tip->setFormat(_hx_tmp7,16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 148)		tip->set_borderSize(( (Float)(2) ));
HXLINE( 149)		this->add(tip);
HXLINE( 151)		this->tipTxt =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,tipX,(tipY + 24),0,HX_("",00,00,00,00),16,null());
HXLINE( 152)		 ::flixel::text::FlxText _hx_tmp8 = this->tipTxt;
HXDLIN( 152)		::String file1 = ::backend::Paths_obj::modFolders((HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82)));
HXDLIN( 152)		::String _hx_tmp9;
HXDLIN( 152)		if (::sys::FileSystem_obj::exists(file1)) {
HXLINE( 152)			_hx_tmp9 = file1;
            		}
            		else {
HXLINE( 152)			_hx_tmp9 = (HX_("assets/fonts/",37,ff,a5,9c) + HX_("vcr.ttf",9d,d2,a7,82));
            		}
HXDLIN( 152)		_hx_tmp8->setFormat(_hx_tmp9,16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 153)		this->tipTxt->set_borderSize(( (Float)(2) ));
HXLINE( 154)		this->add(this->tipTxt);
HXLINE( 155)		this->updateTip();
HXLINE( 157)		this->controllerPointer =  ::flixel::addons::display::shapes::FlxShapeCircle_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(20) ), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("thickness",74,f1,66,5a),0)),-1);
HXLINE( 158)		{
HXLINE( 158)			 ::flixel::math::FlxBasePoint this4 = this->controllerPointer->offset;
HXDLIN( 158)			this4->set_x(( (Float)(20) ));
HXDLIN( 158)			this4->set_y(( (Float)(20) ));
            		}
HXLINE( 159)		{
HXLINE( 159)			 ::flixel::FlxSprite _this = this->controllerPointer;
HXDLIN( 159)			int axes1 = 17;
HXDLIN( 159)			bool _hx_tmp10;
HXDLIN( 159)			if ((axes1 != 1)) {
HXLINE( 159)				_hx_tmp10 = (axes1 == 17);
            			}
            			else {
HXLINE( 159)				_hx_tmp10 = true;
            			}
HXDLIN( 159)			if (_hx_tmp10) {
HXLINE( 159)				int _hx_tmp = ::flixel::FlxG_obj::width;
HXDLIN( 159)				_this->set_x(((( (Float)(_hx_tmp) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 159)			bool _hx_tmp11;
HXDLIN( 159)			if ((axes1 != 16)) {
HXLINE( 159)				_hx_tmp11 = (axes1 == 17);
            			}
            			else {
HXLINE( 159)				_hx_tmp11 = true;
            			}
HXDLIN( 159)			if (_hx_tmp11) {
HXLINE( 159)				int _hx_tmp = ::flixel::FlxG_obj::height;
HXDLIN( 159)				_this->set_y(((( (Float)(_hx_tmp) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 160)		this->controllerPointer->set_alpha(((Float)0.6));
HXLINE( 161)		this->add(this->controllerPointer);
HXLINE( 163)		::flixel::FlxG_obj::mouse->set_visible(!(::backend::Controls_obj::instance->controllerMode));
HXLINE( 164)		this->controllerPointer->set_visible(::backend::Controls_obj::instance->controllerMode);
HXLINE( 165)		this->_lastControllerMode = ::backend::Controls_obj::instance->controllerMode;
            	}

Dynamic NotesSubState_obj::__CreateEmpty() { return new NotesSubState_obj; }

void *NotesSubState_obj::_hx_vtable = 0;

Dynamic NotesSubState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NotesSubState_obj > _hx_result = new NotesSubState_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool NotesSubState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5661ffbf) {
		if (inClassId<=(int)0x3c0818b8) {
			if (inClassId<=(int)0x1154fc14) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1154fc14;
			} else {
				return inClassId==(int)0x3c0818b8;
			}
		} else {
			return inClassId==(int)0x5661ffbf;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void NotesSubState_obj::updateTip(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_170_updateTip)
HXDLIN( 170)		::String _hx_tmp;
HXDLIN( 170)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXDLIN( 170)			_hx_tmp = HX_("Shift",62,5c,50,0f);
            		}
            		else {
HXDLIN( 170)			_hx_tmp = HX_("Left Shoulder Button",b9,84,12,11);
            		}
HXDLIN( 170)		this->tipTxt->set_text(((HX_("Hold ",e1,bd,8a,be) + _hx_tmp) + HX_(" + Press RELOAD to fully reset the selected Note.",fd,d0,6c,73)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,updateTip,(void))

void NotesSubState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_181_update)
HXDLIN( 181)		 ::options::NotesSubState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 182)		if (::backend::Controls_obj::instance->get_BACK()) {
HXLINE( 183)			::flixel::FlxG_obj::mouse->set_visible(false);
HXLINE( 184)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 184)			_hx_tmp->play(::backend::Paths_obj::sound(HX_("cancelMenu",39,a4,43,b7),null()),null(),null(),null(),null(),null());
HXLINE( 185)			this->close();
HXLINE( 186)			return;
            		}
HXLINE( 189)		this->super::update(elapsed);
HXLINE( 192)		if (::flixel::FlxG_obj::gamepads->anyHasState(-2,2)) {
HXLINE( 192)			::backend::Controls_obj::instance->controllerMode = true;
            		}
            		else {
HXLINE( 193)			bool _hx_tmp;
HXDLIN( 193)			bool _hx_tmp1;
HXDLIN( 193)			if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 193)				 ::flixel::input::mouse::FlxMouse _this = ::flixel::FlxG_obj::mouse;
HXDLIN( 193)				_hx_tmp1 = ((_this->screenX - _this->_prevScreenX) != 0);
            			}
            			else {
HXLINE( 193)				_hx_tmp1 = true;
            			}
HXDLIN( 193)			if (!(_hx_tmp1)) {
HXLINE( 193)				 ::flixel::input::mouse::FlxMouse _this = ::flixel::FlxG_obj::mouse;
HXDLIN( 193)				_hx_tmp = ((_this->screenY - _this->_prevScreenY) != 0);
            			}
            			else {
HXLINE( 193)				_hx_tmp = true;
            			}
HXDLIN( 193)			if (_hx_tmp) {
HXLINE( 193)				::backend::Controls_obj::instance->controllerMode = false;
            			}
            		}
HXLINE( 196)		bool changedToController = false;
HXLINE( 197)		if ((::backend::Controls_obj::instance->controllerMode != this->_lastControllerMode)) {
HXLINE( 200)			::flixel::FlxG_obj::mouse->set_visible(!(::backend::Controls_obj::instance->controllerMode));
HXLINE( 201)			this->controllerPointer->set_visible(::backend::Controls_obj::instance->controllerMode);
HXLINE( 204)			if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 206)				this->controllerPointer->set_x(( (Float)(::flixel::FlxG_obj::mouse->x) ));
HXLINE( 207)				this->controllerPointer->set_y(( (Float)(::flixel::FlxG_obj::mouse->y) ));
HXLINE( 208)				changedToController = true;
            			}
HXLINE( 218)			this->_lastControllerMode = ::backend::Controls_obj::instance->controllerMode;
HXLINE( 219)			this->updateTip();
            		}
HXLINE( 223)		Float analogX = ( (Float)(0) );
HXLINE( 224)		Float analogY = ( (Float)(0) );
HXLINE( 225)		bool analogMoved = false;
HXLINE( 226)		bool _hx_tmp;
HXDLIN( 226)		if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 226)			if (!(changedToController)) {
HXLINE( 226)				_hx_tmp = ::flixel::FlxG_obj::gamepads->anyInput();
            			}
            			else {
HXLINE( 226)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 226)			_hx_tmp = false;
            		}
HXDLIN( 226)		if (_hx_tmp) {
HXLINE( 228)			{
HXLINE( 228)				int _g = 0;
HXDLIN( 228)				::Array< ::Dynamic> _g1 = ::flixel::FlxG_obj::gamepads->getActiveGamepads(null());
HXDLIN( 228)				while((_g < _g1->length)){
HXLINE( 228)					 ::flixel::input::gamepad::FlxGamepad gamepad = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepad >();
HXDLIN( 228)					_g = (_g + 1);
HXLINE( 230)					analogX = gamepad->getAnalogXAxisValue(gamepad->mapping->getAnalogStick(19));
HXLINE( 231)					analogY = gamepad->getYAxisRaw(gamepad->mapping->getAnalogStick(19));
HXLINE( 232)					if ((analogX == 0)) {
HXLINE( 232)						analogMoved = (analogY != 0);
            					}
            					else {
HXLINE( 232)						analogMoved = true;
            					}
HXLINE( 233)					if (analogMoved) {
HXLINE( 233)						goto _hx_goto_3;
            					}
            				}
            				_hx_goto_3:;
            			}
HXLINE( 235)			this->controllerPointer->set_x(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)(::flixel::FlxG_obj::width) ),(this->controllerPointer->x + ((analogX * ( (Float)(1000) )) * elapsed)))));
HXLINE( 236)			this->controllerPointer->set_y(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)(::flixel::FlxG_obj::height) ),(this->controllerPointer->y + ((analogY * ( (Float)(1000) )) * elapsed)))));
            		}
HXLINE( 238)		bool controllerPressed;
HXDLIN( 238)		if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 238)			controllerPressed = ::backend::Controls_obj::instance->get_ACCEPT();
            		}
            		else {
HXLINE( 238)			controllerPressed = false;
            		}
HXLINE( 241)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 241)		if (_this->keyManager->checkStatusUnsafe(17,_this->status)) {
HXLINE( 243)			this->onPixel = !(this->onPixel);
HXLINE( 244)			this->spawnNotes();
HXLINE( 245)			this->updateNotes(true);
HXLINE( 246)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 246)			_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            		}
HXLINE( 249)		if ((this->hexTypeNum > -1)) {
HXLINE( 251)			int keyPressed = ::flixel::FlxG_obj::keys->firstJustPressed();
HXLINE( 252)			 ::options::NotesSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 252)			_hx_tmp->hexTypeVisibleTimer = (_hx_tmp->hexTypeVisibleTimer + elapsed);
HXLINE( 253)			bool changed = false;
HXLINE( 254)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 254)			changed = _this->keyManager->checkStatusUnsafe(37,_this->status);
HXDLIN( 254)			if (changed) {
HXLINE( 255)				this->hexTypeNum--;
            			}
            			else {
HXLINE( 256)				 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 256)				changed = _this->keyManager->checkStatusUnsafe(39,_this->status);
HXDLIN( 256)				if (changed) {
HXLINE( 257)					this->hexTypeNum++;
            				}
            				else {
HXLINE( 258)					if (this->allowedTypeKeys->exists(keyPressed)) {
HXLINE( 261)						::String curColor = this->alphabetHex->text;
HXLINE( 262)						::String newColor = curColor.substring(0,this->hexTypeNum);
HXDLIN( 262)						::String newColor1 = (newColor + this->allowedTypeKeys->get(keyPressed));
HXDLIN( 262)						::String newColor2 = (newColor1 + curColor.substring((this->hexTypeNum + 1),null()));
HXLINE( 264)						int colorHex = ( (int)(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + newColor2))) );
HXLINE( 265)						this->setShaderColor(colorHex);
HXLINE( 266)						this->_storedColor = this->getShaderColor();
HXLINE( 267)						this->updateColors(null());
HXLINE( 270)						this->hexTypeNum++;
HXLINE( 271)						changed = true;
            					}
            					else {
HXLINE( 273)						 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 273)						if (_this->keyManager->checkStatusUnsafe(13,_this->status)) {
HXLINE( 274)							this->hexTypeNum = -1;
            						}
            					}
            				}
            			}
HXLINE( 276)			bool end = false;
HXLINE( 277)			if (changed) {
HXLINE( 279)				if ((this->hexTypeNum > 5)) {
HXLINE( 281)					this->hexTypeNum = -1;
HXLINE( 282)					end = true;
HXLINE( 283)					this->hexTypeLine->set_visible(false);
            				}
            				else {
HXLINE( 287)					if ((this->hexTypeNum < 0)) {
HXLINE( 287)						this->hexTypeNum = 0;
            					}
            					else {
HXLINE( 288)						if ((this->hexTypeNum > 5)) {
HXLINE( 288)							this->hexTypeNum = 5;
            						}
            					}
HXLINE( 289)					this->centerHexTypeLine();
HXLINE( 290)					this->hexTypeLine->set_visible(true);
            				}
HXLINE( 292)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 292)				_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            			}
HXLINE( 294)			if (!(end)) {
HXLINE( 294)				this->hexTypeLine->set_visible((::hx::Mod(::Math_obj::floor((this->hexTypeVisibleTimer * ( (Float)(2) ))),2) == 0));
            			}
            		}
            		else {
HXLINE( 298)			int add = 0;
HXLINE( 299)			bool _hx_tmp;
HXDLIN( 299)			if ((analogX == 0)) {
HXLINE( 299)				_hx_tmp = !(changedToController);
            			}
            			else {
HXLINE( 299)				_hx_tmp = false;
            			}
HXDLIN( 299)			if (_hx_tmp) {
HXLINE( 301)				if (::backend::Controls_obj::instance->get_UI_LEFT_P()) {
HXLINE( 301)					add = -1;
            				}
            				else {
HXLINE( 302)					if (::backend::Controls_obj::instance->get_UI_RIGHT_P()) {
HXLINE( 302)						add = 1;
            					}
            				}
            			}
HXLINE( 305)			bool _hx_tmp1;
HXDLIN( 305)			bool _hx_tmp2;
HXDLIN( 305)			if ((analogY == 0)) {
HXLINE( 305)				_hx_tmp2 = !(changedToController);
            			}
            			else {
HXLINE( 305)				_hx_tmp2 = false;
            			}
HXDLIN( 305)			if (_hx_tmp2) {
HXLINE( 305)				if (!(::backend::Controls_obj::instance->get_UI_UP_P())) {
HXLINE( 305)					_hx_tmp1 = ::backend::Controls_obj::instance->get_UI_DOWN_P();
            				}
            				else {
HXLINE( 305)					_hx_tmp1 = true;
            				}
            			}
            			else {
HXLINE( 305)				_hx_tmp1 = false;
            			}
HXDLIN( 305)			if (_hx_tmp1) {
HXLINE( 307)				this->onModeColumn = !(this->onModeColumn);
HXLINE( 308)				this->modeBG->set_visible(this->onModeColumn);
HXLINE( 309)				this->notesBG->set_visible(!(this->onModeColumn));
            			}
HXLINE( 312)			if ((add != 0)) {
HXLINE( 314)				if (this->onModeColumn) {
HXLINE( 314)					this->changeSelectionMode(add);
            				}
            				else {
HXLINE( 315)					this->changeSelectionNote(add);
            				}
            			}
HXLINE( 317)			this->hexTypeLine->set_visible(false);
            		}
HXLINE( 321)		bool generalMoved;
HXDLIN( 321)		 ::flixel::input::mouse::FlxMouse _this1 = ::flixel::FlxG_obj::mouse;
HXDLIN( 321)		bool generalMoved1;
HXDLIN( 321)		if ((_this1->_prevX == _this1->x)) {
HXLINE( 321)			generalMoved1 = (_this1->_prevY != _this1->y);
            		}
            		else {
HXLINE( 321)			generalMoved1 = true;
            		}
HXDLIN( 321)		if (!(generalMoved1)) {
HXLINE( 321)			generalMoved = analogMoved;
            		}
            		else {
HXLINE( 321)			generalMoved = true;
            		}
HXLINE( 322)		bool generalPressed;
HXDLIN( 322)		if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 322)			generalPressed = controllerPressed;
            		}
            		else {
HXLINE( 322)			generalPressed = true;
            		}
HXLINE( 323)		if (generalMoved) {
HXLINE( 325)			this->copyButton->set_alpha(((Float)0.6));
HXLINE( 326)			this->pasteButton->set_alpha(((Float)0.6));
            		}
HXLINE( 329)		if (this->pointerOverlaps(this->copyButton)) {
HXLINE( 331)			this->copyButton->set_alpha(( (Float)(1) ));
HXLINE( 332)			if (generalPressed) {
HXLINE( 334)				int this1 = this->getShaderColor();
HXDLIN( 334)				::String _hx_tmp = (HX_("",00,00,00,00) + ::StringTools_obj::hex(((this1 >> 16) & 255),2));
HXDLIN( 334)				::String _hx_tmp1 = (_hx_tmp + ::StringTools_obj::hex(((this1 >> 8) & 255),2));
HXDLIN( 334)				::lime::_hx_system::Clipboard_obj::set_text((_hx_tmp1 + ::StringTools_obj::hex((this1 & 255),2)));
HXLINE( 335)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp2 = ::flixel::FlxG_obj::sound;
HXDLIN( 335)				_hx_tmp2->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 336)				 ::Dynamic _hx_tmp3 = ::haxe::Log_obj::trace;
HXDLIN( 336)				::String _hx_tmp4 = (HX_("copied: ",ea,92,6a,a6) + ::lime::_hx_system::Clipboard_obj::get_text());
HXDLIN( 336)				_hx_tmp3(_hx_tmp4,::hx::SourceInfo(HX_("source/options/NotesSubState.hx",51,fc,98,b4),336,HX_("options.NotesSubState",a2,74,fa,0a),HX_("update",09,86,05,87)));
            			}
HXLINE( 338)			this->hexTypeNum = -1;
            		}
            		else {
HXLINE( 340)			if (this->pointerOverlaps(this->pasteButton)) {
HXLINE( 342)				this->pasteButton->set_alpha(( (Float)(1) ));
HXLINE( 343)				if (generalPressed) {
HXLINE( 345)					::String formattedText = ::StringTools_obj::replace(::StringTools_obj::replace(::StringTools_obj::trim(::lime::_hx_system::Clipboard_obj::get_text()).toUpperCase(),HX_("#",23,00,00,00),HX_("",00,00,00,00)),HX_("0x",48,2a,00,00),HX_("",00,00,00,00));
HXLINE( 346)					 ::Dynamic newColor = ::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + formattedText));
HXLINE( 348)					bool _hx_tmp;
HXDLIN( 348)					if (::hx::IsNotNull( newColor )) {
HXLINE( 348)						_hx_tmp = (formattedText.length == 6);
            					}
            					else {
HXLINE( 348)						_hx_tmp = false;
            					}
HXDLIN( 348)					if (_hx_tmp) {
HXLINE( 350)						this->setShaderColor(( (int)(newColor) ));
HXLINE( 351)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 351)						_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 352)						this->_storedColor = this->getShaderColor();
HXLINE( 353)						this->updateColors(null());
            					}
            					else {
HXLINE( 356)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 356)						_hx_tmp->play(::backend::Paths_obj::sound(HX_("cancelMenu",39,a4,43,b7),null()),((Float)0.6),null(),null(),null(),null());
            					}
            				}
HXLINE( 358)				this->hexTypeNum = -1;
            			}
            		}
HXLINE( 362)		if (generalPressed) {
HXLINE( 364)			this->hexTypeNum = -1;
HXLINE( 365)			if (this->pointerOverlaps(this->modeNotes)) {
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::options::NotesSubState,_gthis) HXARGC(1)
            				void _hx_run( ::flixel::FlxSprite note){
            					HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_368_update)
HXLINE( 368)					bool _hx_tmp;
HXDLIN( 368)					if ((_gthis->curSelectedMode != note->ID)) {
HXLINE( 368)						_hx_tmp = _gthis->pointerOverlaps(note);
            					}
            					else {
HXLINE( 368)						_hx_tmp = false;
            					}
HXDLIN( 368)					if (_hx_tmp) {
HXLINE( 370)						 ::flixel::FlxSprite _gthis1 = _gthis->modeBG;
HXDLIN( 370)						_gthis1->set_visible(_gthis->notesBG->set_visible(false));
HXLINE( 371)						_gthis->curSelectedMode = note->ID;
HXLINE( 372)						_gthis->onModeColumn = true;
HXLINE( 373)						_gthis->updateNotes(null());
HXLINE( 374)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 374)						_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            					}
            				}
            				HX_END_LOCAL_FUNC1((void))

HXLINE( 367)				this->modeNotes->forEachAlive( ::Dynamic(new _hx_Closure_0(_gthis)),null());
            			}
            			else {
HXLINE( 378)				if (this->pointerOverlaps(this->myNotes)) {
            					HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::options::NotesSubState,_gthis) HXARGC(1)
            					void _hx_run( ::objects::StrumNote note){
            						HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_381_update)
HXLINE( 381)						bool _hx_tmp;
HXDLIN( 381)						if ((_gthis->curSelectedNote != note->ID)) {
HXLINE( 381)							_hx_tmp = _gthis->pointerOverlaps(note);
            						}
            						else {
HXLINE( 381)							_hx_tmp = false;
            						}
HXDLIN( 381)						if (_hx_tmp) {
HXLINE( 383)							 ::flixel::FlxSprite _gthis1 = _gthis->modeBG;
HXDLIN( 383)							_gthis1->set_visible(_gthis->notesBG->set_visible(false));
HXLINE( 384)							_gthis->curSelectedNote = note->ID;
HXLINE( 385)							_gthis->onModeColumn = false;
HXLINE( 386)							_gthis->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(note->ID).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 387)							_gthis->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(note->ID).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 388)							_gthis->updateNotes(null());
HXLINE( 389)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 389)							_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            						}
            					}
            					HX_END_LOCAL_FUNC1((void))

HXLINE( 380)					this->myNotes->forEachAlive( ::Dynamic(new _hx_Closure_1(_gthis)),null());
            				}
            				else {
HXLINE( 393)					if (this->pointerOverlaps(this->colorWheel)) {
HXLINE( 394)						this->_storedColor = this->getShaderColor();
HXLINE( 395)						this->holdingOnObj = this->colorWheel;
            					}
            					else {
HXLINE( 397)						if (this->pointerOverlaps(this->colorGradient)) {
HXLINE( 398)							this->_storedColor = this->getShaderColor();
HXLINE( 399)							this->holdingOnObj = this->colorGradient;
            						}
            						else {
HXLINE( 401)							if (this->pointerOverlaps(this->colorPalette)) {
HXLINE( 402)								 ::openfl::display::BitmapData _hx_tmp = this->colorPalette->get_pixels();
HXLINE( 403)								Float _hx_tmp1 = this->pointerX();
HXDLIN( 403)								int _hx_tmp2 = ::Std_obj::_hx_int(((_hx_tmp1 - this->colorPalette->x) / this->colorPalette->scale->x));
HXLINE( 404)								Float _hx_tmp3 = this->pointerY();
HXLINE( 402)								this->setShaderColor(_hx_tmp->getPixel32(_hx_tmp2,::Std_obj::_hx_int(((_hx_tmp3 - this->colorPalette->y) / this->colorPalette->scale->y))));
HXLINE( 405)								 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp4 = ::flixel::FlxG_obj::sound;
HXDLIN( 405)								_hx_tmp4->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 406)								this->updateColors(null());
            							}
            							else {
HXLINE( 408)								if (this->pointerOverlaps(this->skinNote)) {
HXLINE( 410)									this->onPixel = !(this->onPixel);
HXLINE( 411)									this->spawnNotes();
HXLINE( 412)									this->updateNotes(true);
HXLINE( 413)									 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 413)									_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            								}
            								else {
HXLINE( 415)									bool _hx_tmp;
HXDLIN( 415)									bool _hx_tmp1;
HXDLIN( 415)									Float _hx_tmp2 = this->pointerY();
HXDLIN( 415)									if ((_hx_tmp2 >= this->hexTypeLine->y)) {
HXLINE( 415)										Float _hx_tmp = this->pointerY();
HXDLIN( 415)										Float _hx_tmp2 = this->hexTypeLine->y;
HXDLIN( 415)										_hx_tmp1 = (_hx_tmp < (_hx_tmp2 + this->hexTypeLine->get_height()));
            									}
            									else {
HXLINE( 415)										_hx_tmp1 = false;
            									}
HXDLIN( 415)									if (_hx_tmp1) {
HXLINE( 415)										_hx_tmp = (::Math_obj::abs((this->pointerX() - ( (Float)(1000) ))) <= 84);
            									}
            									else {
HXLINE( 415)										_hx_tmp = false;
            									}
HXDLIN( 415)									if (_hx_tmp) {
HXLINE( 418)										this->hexTypeNum = 0;
HXLINE( 419)										{
HXLINE( 419)											int _g = 0;
HXDLIN( 419)											::Array< ::Dynamic> _g1 = this->alphabetHex->letters;
HXDLIN( 419)											while((_g < _g1->length)){
HXLINE( 419)												 ::objects::AlphaCharacter letter = _g1->__get(_g).StaticCast<  ::objects::AlphaCharacter >();
HXDLIN( 419)												_g = (_g + 1);
HXLINE( 421)												Float _hx_tmp = (letter->x - letter->offset->x);
HXDLIN( 421)												Float _hx_tmp1 = (_hx_tmp + letter->get_width());
HXDLIN( 421)												if ((_hx_tmp1 <= this->pointerX())) {
HXLINE( 421)													this->hexTypeNum++;
            												}
            												else {
HXLINE( 422)													goto _hx_goto_4;
            												}
            											}
            											_hx_goto_4:;
            										}
HXLINE( 424)										if ((this->hexTypeNum > 5)) {
HXLINE( 424)											this->hexTypeNum = 5;
            										}
HXLINE( 425)										this->hexTypeLine->set_visible(true);
HXLINE( 426)										this->centerHexTypeLine();
            									}
            									else {
HXLINE( 428)										this->holdingOnObj = null();
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 431)		if (::hx::IsNotNull( this->holdingOnObj )) {
HXLINE( 433)			bool _hx_tmp;
HXDLIN( 433)			if ((::flixel::FlxG_obj::mouse->_leftButton->current != -1)) {
HXLINE( 433)				if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 433)					_hx_tmp = ::backend::Controls_obj::instance->justReleased(HX_("accept",08,93,06,0b));
            				}
            				else {
HXLINE( 433)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE( 433)				_hx_tmp = true;
            			}
HXDLIN( 433)			if (_hx_tmp) {
HXLINE( 435)				this->holdingOnObj = null();
HXLINE( 436)				this->_storedColor = this->getShaderColor();
HXLINE( 437)				this->updateColors(null());
HXLINE( 438)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 438)				_hx_tmp->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),((Float)0.6),null(),null(),null(),null());
            			}
            			else {
HXLINE( 440)				bool _hx_tmp;
HXDLIN( 440)				if (!(generalMoved)) {
HXLINE( 440)					_hx_tmp = generalPressed;
            				}
            				else {
HXLINE( 440)					_hx_tmp = true;
            				}
HXDLIN( 440)				if (_hx_tmp) {
HXLINE( 442)					if (::hx::IsInstanceEq( this->holdingOnObj,this->colorGradient )) {
HXLINE( 444)						Float Value = this->pointerY();
HXDLIN( 444)						Float Value1 = (Value - this->colorGradient->y);
HXDLIN( 444)						Float Value2 = (Value1 / this->colorGradient->get_height());
HXDLIN( 444)						Float lowerBound;
HXDLIN( 444)						if ((Value2 < 0)) {
HXLINE( 444)							lowerBound = ( (Float)(0) );
            						}
            						else {
HXLINE( 444)							lowerBound = Value2;
            						}
HXDLIN( 444)						Float newBrightness;
HXDLIN( 444)						if ((lowerBound > 1)) {
HXLINE( 444)							newBrightness = ( (Float)(1) );
            						}
            						else {
HXLINE( 444)							newBrightness = lowerBound;
            						}
HXDLIN( 444)						Float newBrightness1 = (( (Float)(1) ) - newBrightness);
HXLINE( 445)						{
HXLINE( 445)							 ::options::NotesSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 445)							_hx_tmp->_storedColor = (_hx_tmp->_storedColor & 16777215);
HXDLIN( 445)							 ::options::NotesSubState _hx_tmp1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 445)							_hx_tmp1->_storedColor = (_hx_tmp1->_storedColor | 16777216);
            						}
HXLINE( 446)						int this1 = this->_storedColor;
HXDLIN( 446)						if ((::Math_obj::max((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this1 & 255)) ) / ( (Float)(255) )))) == 0)) {
HXLINE( 447)							Float Alpha = ( (Float)(1) );
HXDLIN( 447)							int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 447)							{
HXLINE( 447)								int Value = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 447)								color = (color & -16711681);
HXDLIN( 447)								int color1;
HXDLIN( 447)								if ((Value > 255)) {
HXLINE( 447)									color1 = 255;
            								}
            								else {
HXLINE( 447)									if ((Value < 0)) {
HXLINE( 447)										color1 = 0;
            									}
            									else {
HXLINE( 447)										color1 = Value;
            									}
            								}
HXDLIN( 447)								color = (color | (color1 << 16));
            							}
HXDLIN( 447)							{
HXLINE( 447)								int Value1 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 447)								color = (color & -65281);
HXDLIN( 447)								int color2;
HXDLIN( 447)								if ((Value1 > 255)) {
HXLINE( 447)									color2 = 255;
            								}
            								else {
HXLINE( 447)									if ((Value1 < 0)) {
HXLINE( 447)										color2 = 0;
            									}
            									else {
HXLINE( 447)										color2 = Value1;
            									}
            								}
HXDLIN( 447)								color = (color | (color2 << 8));
            							}
HXDLIN( 447)							{
HXLINE( 447)								int Value2 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 447)								color = (color & -256);
HXDLIN( 447)								int color3;
HXDLIN( 447)								if ((Value2 > 255)) {
HXLINE( 447)									color3 = 255;
            								}
            								else {
HXLINE( 447)									if ((Value2 < 0)) {
HXLINE( 447)										color3 = 0;
            									}
            									else {
HXLINE( 447)										color3 = Value2;
            									}
            								}
HXDLIN( 447)								color = (color | color3);
            							}
HXDLIN( 447)							{
HXLINE( 447)								int Value3 = ::Math_obj::round((Alpha * ( (Float)(255) )));
HXDLIN( 447)								color = (color & 16777215);
HXDLIN( 447)								int color4;
HXDLIN( 447)								if ((Value3 > 255)) {
HXLINE( 447)									color4 = 255;
            								}
            								else {
HXLINE( 447)									if ((Value3 < 0)) {
HXLINE( 447)										color4 = 0;
            									}
            									else {
HXLINE( 447)										color4 = Value3;
            									}
            								}
HXDLIN( 447)								color = (color | (color4 << 24));
            							}
HXDLIN( 447)							this->setShaderColor(color);
            						}
            						else {
HXLINE( 449)							Float _hx_tmp = ::flixel::util::_FlxColor::FlxColor_Impl__obj::get_hue(this->_storedColor);
HXDLIN( 449)							int this1 = this->_storedColor;
HXDLIN( 449)							this->setShaderColor(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(_hx_tmp,((::Math_obj::max((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this1 & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this1 & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this1 & 255)) ) / ( (Float)(255) ))))),newBrightness1,null()));
            						}
HXLINE( 450)						this->updateColors(this->_storedColor);
            					}
            					else {
HXLINE( 452)						if (::hx::IsInstanceEq( this->holdingOnObj,this->colorWheel )) {
HXLINE( 454)							Float x = this->colorWheel->x;
HXDLIN( 454)							Float x1 = (x + (this->colorWheel->get_width() / ( (Float)(2) )));
HXDLIN( 454)							Float y = this->colorWheel->y;
HXDLIN( 454)							 ::flixel::math::FlxBasePoint this1 =  ::flixel::math::FlxBasePoint_obj::__alloc( HX_CTX ,x1,(y + (this->colorWheel->get_height() / ( (Float)(2) ))));
HXDLIN( 454)							 ::flixel::math::FlxBasePoint center = this1;
HXLINE( 455)							 ::flixel::math::FlxBasePoint mouse = this->pointerFlxPoint();
HXLINE( 456)							Float x2 = (center->x - mouse->x);
HXDLIN( 456)							Float y1 = (center->y - mouse->y);
HXDLIN( 456)							Float hue = ( (Float)(::flixel::math::FlxMath_obj::wrap((::flixel::math::FlxMath_obj::wrap(::Std_obj::_hx_int((::Math_obj::atan2(y1,x2) * (( (Float)(180) ) / ::Math_obj::PI))),0,360) - 90),0,360)) );
HXLINE( 457)							Float dx = (center->x - mouse->x);
HXDLIN( 457)							Float dy = (center->y - mouse->y);
HXDLIN( 457)							if (center->_weak) {
HXLINE( 457)								center->put();
            							}
HXDLIN( 457)							Float Value = ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
HXDLIN( 457)							Float Value1 = ((Value / this->colorWheel->get_width()) * ( (Float)(2) ));
HXDLIN( 457)							Float lowerBound;
HXDLIN( 457)							if ((Value1 < 0)) {
HXLINE( 457)								lowerBound = ( (Float)(0) );
            							}
            							else {
HXLINE( 457)								lowerBound = Value1;
            							}
HXDLIN( 457)							Float sat;
HXDLIN( 457)							if ((lowerBound > 1)) {
HXLINE( 457)								sat = ( (Float)(1) );
            							}
            							else {
HXLINE( 457)								sat = lowerBound;
            							}
HXLINE( 459)							if ((sat != 0)) {
HXLINE( 459)								int this1 = this->_storedColor;
HXDLIN( 459)								this->setShaderColor(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(hue,sat,::Math_obj::max((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this1 & 255)) ) / ( (Float)(255) )))),null()));
            							}
            							else {
HXLINE( 460)								int this1 = this->_storedColor;
HXDLIN( 460)								Float Red = ::Math_obj::max((( (Float)(((this1 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this1 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this1 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 460)								int this2 = this->_storedColor;
HXDLIN( 460)								Float Green = ::Math_obj::max((( (Float)(((this2 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this2 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this2 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 460)								int this3 = this->_storedColor;
HXDLIN( 460)								Float Blue = ::Math_obj::max((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 460)								Float Alpha = ( (Float)(1) );
HXDLIN( 460)								int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 460)								{
HXLINE( 460)									int Value = ::Math_obj::round((Red * ( (Float)(255) )));
HXDLIN( 460)									color = (color & -16711681);
HXDLIN( 460)									int color1;
HXDLIN( 460)									if ((Value > 255)) {
HXLINE( 460)										color1 = 255;
            									}
            									else {
HXLINE( 460)										if ((Value < 0)) {
HXLINE( 460)											color1 = 0;
            										}
            										else {
HXLINE( 460)											color1 = Value;
            										}
            									}
HXDLIN( 460)									color = (color | (color1 << 16));
            								}
HXDLIN( 460)								{
HXLINE( 460)									int Value1 = ::Math_obj::round((Green * ( (Float)(255) )));
HXDLIN( 460)									color = (color & -65281);
HXDLIN( 460)									int color2;
HXDLIN( 460)									if ((Value1 > 255)) {
HXLINE( 460)										color2 = 255;
            									}
            									else {
HXLINE( 460)										if ((Value1 < 0)) {
HXLINE( 460)											color2 = 0;
            										}
            										else {
HXLINE( 460)											color2 = Value1;
            										}
            									}
HXDLIN( 460)									color = (color | (color2 << 8));
            								}
HXDLIN( 460)								{
HXLINE( 460)									int Value2 = ::Math_obj::round((Blue * ( (Float)(255) )));
HXDLIN( 460)									color = (color & -256);
HXDLIN( 460)									int color3;
HXDLIN( 460)									if ((Value2 > 255)) {
HXLINE( 460)										color3 = 255;
            									}
            									else {
HXLINE( 460)										if ((Value2 < 0)) {
HXLINE( 460)											color3 = 0;
            										}
            										else {
HXLINE( 460)											color3 = Value2;
            										}
            									}
HXDLIN( 460)									color = (color | color3);
            								}
HXDLIN( 460)								{
HXLINE( 460)									int Value3 = ::Math_obj::round((Alpha * ( (Float)(255) )));
HXDLIN( 460)									color = (color & 16777215);
HXDLIN( 460)									int color4;
HXDLIN( 460)									if ((Value3 > 255)) {
HXLINE( 460)										color4 = 255;
            									}
            									else {
HXLINE( 460)										if ((Value3 < 0)) {
HXLINE( 460)											color4 = 0;
            										}
            										else {
HXLINE( 460)											color4 = Value3;
            										}
            									}
HXDLIN( 460)									color = (color | (color4 << 24));
            								}
HXDLIN( 460)								this->setShaderColor(color);
            							}
HXLINE( 461)							this->updateColors(null());
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE( 465)			bool _hx_tmp;
HXDLIN( 465)			if (::backend::Controls_obj::instance->get_RESET()) {
HXLINE( 465)				_hx_tmp = (this->hexTypeNum < 0);
            			}
            			else {
HXLINE( 465)				_hx_tmp = false;
            			}
HXDLIN( 465)			if (_hx_tmp) {
HXLINE( 467)				bool _hx_tmp;
HXDLIN( 467)				 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 467)				if (!(_this->keyManager->checkStatusUnsafe(16,_this->status))) {
HXLINE( 467)					_hx_tmp = ::flixel::FlxG_obj::gamepads->anyHasState(4,2);
            				}
            				else {
HXLINE( 467)					_hx_tmp = true;
            				}
HXDLIN( 467)				if (_hx_tmp) {
HXLINE( 470)					{
HXLINE( 471)						 ::shaders::RGBShaderReference strumRGB = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 472)						int color;
HXDLIN( 472)						if (!(this->onPixel)) {
HXLINE( 472)							color = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(0);
            						}
            						else {
HXLINE( 472)							color = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(0);
            						}
HXLINE( 477)						 ::shaders::RGBPalette _hx_tmp = this->getShader();
HXDLIN( 477)						_hx_tmp->set_r(strumRGB->set_r(color));
HXLINE( 483)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[0] = color;
            					}
HXLINE( 470)					{
HXLINE( 471)						 ::shaders::RGBShaderReference strumRGB1 = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 472)						int color1;
HXDLIN( 472)						if (!(this->onPixel)) {
HXLINE( 472)							color1 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(1);
            						}
            						else {
HXLINE( 472)							color1 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(1);
            						}
HXLINE( 479)						 ::shaders::RGBPalette _hx_tmp1 = this->getShader();
HXDLIN( 479)						_hx_tmp1->set_g(strumRGB1->set_g(color1));
HXLINE( 483)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[1] = color1;
            					}
HXLINE( 470)					{
HXLINE( 471)						 ::shaders::RGBShaderReference strumRGB2 = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 472)						int color2;
HXDLIN( 472)						if (!(this->onPixel)) {
HXLINE( 472)							color2 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(2);
            						}
            						else {
HXLINE( 472)							color2 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(2);
            						}
HXLINE( 481)						 ::shaders::RGBPalette _hx_tmp2 = this->getShader();
HXDLIN( 481)						_hx_tmp2->set_b(strumRGB2->set_b(color2));
HXLINE( 483)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[2] = color2;
            					}
            				}
HXLINE( 486)				int _hx_tmp1;
HXDLIN( 486)				if (!(this->onPixel)) {
HXLINE( 486)					_hx_tmp1 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            				}
            				else {
HXLINE( 486)					_hx_tmp1 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            				}
HXDLIN( 486)				this->setShaderColor(_hx_tmp1);
HXLINE( 487)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp2 = ::flixel::FlxG_obj::sound;
HXDLIN( 487)				_hx_tmp2->play(::backend::Paths_obj::sound(HX_("cancelMenu",39,a4,43,b7),null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 488)				this->updateColors(null());
            			}
            		}
            	}


bool NotesSubState_obj::pointerOverlaps( ::Dynamic obj){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_493_pointerOverlaps)
HXLINE( 494)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 494)			return ::flixel::FlxG_obj::mouse->overlaps(( ( ::flixel::FlxBasic)(obj) ),null());
            		}
HXLINE( 495)		return ::flixel::FlxG_obj::overlap(this->controllerPointer,( ( ::flixel::FlxBasic)(obj) ),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,pointerOverlaps,return )

Float NotesSubState_obj::pointerX(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_499_pointerX)
HXLINE( 500)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 500)			return ( (Float)(::flixel::FlxG_obj::mouse->x) );
            		}
HXLINE( 501)		return this->controllerPointer->x;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,pointerX,return )

Float NotesSubState_obj::pointerY(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_504_pointerY)
HXLINE( 505)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 505)			return ( (Float)(::flixel::FlxG_obj::mouse->y) );
            		}
HXLINE( 506)		return this->controllerPointer->y;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,pointerY,return )

 ::flixel::math::FlxBasePoint NotesSubState_obj::pointerFlxPoint(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_509_pointerFlxPoint)
HXLINE( 510)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 510)			return ::flixel::FlxG_obj::mouse->getScreenPosition(null(),null());
            		}
HXLINE( 511)		return this->controllerPointer->getScreenPosition(null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,pointerFlxPoint,return )

void NotesSubState_obj::centerHexTypeLine(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_515_centerHexTypeLine)
HXLINE( 517)		if ((this->hexTypeNum > 0)) {
HXLINE( 519)			 ::objects::AlphaCharacter letter = this->alphabetHex->letters->__get((this->hexTypeNum - 1)).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 520)			 ::flixel::FlxSprite _hx_tmp = this->hexTypeLine;
HXDLIN( 520)			Float _hx_tmp1 = (letter->x - letter->offset->x);
HXDLIN( 520)			_hx_tmp->set_x((_hx_tmp1 + letter->get_width()));
            		}
            		else {
HXLINE( 524)			 ::objects::AlphaCharacter letter = this->alphabetHex->letters->__get(0).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 525)			this->hexTypeLine->set_x((letter->x - letter->offset->x));
            		}
HXLINE( 527)		 ::flixel::FlxSprite fh = this->hexTypeLine;
HXDLIN( 527)		Float fh1 = fh->x;
HXDLIN( 527)		fh->set_x((fh1 + this->hexTypeLine->get_width()));
HXLINE( 528)		this->hexTypeVisibleTimer = ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,centerHexTypeLine,(void))

void NotesSubState_obj::changeSelectionMode(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_531_changeSelectionMode)
HXLINE( 532)		 ::options::NotesSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 532)		_hx_tmp->curSelectedMode = (_hx_tmp->curSelectedMode + change);
HXLINE( 533)		if ((this->curSelectedMode < 0)) {
HXLINE( 534)			this->curSelectedMode = 2;
            		}
HXLINE( 535)		if ((this->curSelectedMode >= 3)) {
HXLINE( 536)			this->curSelectedMode = 0;
            		}
HXLINE( 538)		this->modeBG->set_visible(true);
HXLINE( 539)		this->notesBG->set_visible(false);
HXLINE( 540)		this->updateNotes(null());
HXLINE( 541)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 541)		_hx_tmp1->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,changeSelectionMode,(void))

void NotesSubState_obj::changeSelectionNote(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_543_changeSelectionNote)
HXLINE( 544)		 ::options::NotesSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 544)		_hx_tmp->curSelectedNote = (_hx_tmp->curSelectedNote + change);
HXLINE( 545)		if ((this->curSelectedNote < 0)) {
HXLINE( 546)			this->curSelectedNote = (this->dataArray->length - 1);
            		}
HXLINE( 547)		if ((this->curSelectedNote >= this->dataArray->length)) {
HXLINE( 548)			this->curSelectedNote = 0;
            		}
HXLINE( 550)		this->modeBG->set_visible(false);
HXLINE( 551)		this->notesBG->set_visible(true);
HXLINE( 552)		this->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 553)		this->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 554)		this->updateNotes(null());
HXLINE( 555)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 555)		_hx_tmp1->play(::backend::Paths_obj::sound(HX_("scrollMenu",4c,d4,18,06),null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,changeSelectionNote,(void))

 ::objects::Alphabet NotesSubState_obj::makeColorAlphabet(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_560_makeColorAlphabet)
HXLINE( 561)		 ::objects::Alphabet text =  ::objects::Alphabet_obj::__alloc( HX_CTX ,x,y,HX_("",00,00,00,00),true);
HXLINE( 562)		text->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE( 563)		text->setScale(((Float)0.6),null());
HXLINE( 564)		this->add(text);
HXLINE( 565)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC2(NotesSubState_obj,makeColorAlphabet,return )

void NotesSubState_obj::spawnNotes(){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		void _hx_run( ::flixel::FlxSprite note){
            			HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_579_spawnNotes)
HXLINE( 580)			note->kill();
HXLINE( 581)			note->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            		void _hx_run( ::objects::StrumNote note){
            			HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_583_spawnNotes)
HXLINE( 584)			note->kill();
HXLINE( 585)			note->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_574_spawnNotes)
HXLINE( 575)		::Array< ::Dynamic> _hx_tmp;
HXDLIN( 575)		if (!(this->onPixel)) {
HXLINE( 575)			_hx_tmp = ::backend::ClientPrefs_obj::data->arrowRGB;
            		}
            		else {
HXLINE( 575)			_hx_tmp = ::backend::ClientPrefs_obj::data->arrowRGBPixel;
            		}
HXDLIN( 575)		this->dataArray = _hx_tmp;
HXLINE( 576)		if (this->onPixel) {
HXLINE( 576)			::states::PlayState_obj::stageUI = HX_("pixel",86,c6,a3,c2);
            		}
HXLINE( 579)		this->modeNotes->forEachAlive( ::Dynamic(new _hx_Closure_0()),null());
HXLINE( 583)		this->myNotes->forEachAlive( ::Dynamic(new _hx_Closure_1()),null());
HXLINE( 587)		this->modeNotes->clear();
HXLINE( 588)		this->myNotes->clear();
HXLINE( 590)		if (::hx::IsNotNull( this->skinNote )) {
HXLINE( 592)			this->remove(this->skinNote,null());
HXLINE( 593)			this->skinNote->destroy();
            		}
HXLINE( 595)		if (::hx::IsNotNull( this->bigNote )) {
HXLINE( 597)			this->remove(this->bigNote,null());
HXLINE( 598)			this->bigNote->destroy();
            		}
HXLINE( 602)		int res;
HXDLIN( 602)		if (this->onPixel) {
HXLINE( 602)			res = 160;
            		}
            		else {
HXLINE( 602)			res = 17;
            		}
HXLINE( 603)		 ::flixel::FlxSprite _hx_tmp1 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,48,24,null());
HXDLIN( 603)		::String _hx_tmp2;
HXDLIN( 603)		if (this->onPixel) {
HXLINE( 603)			_hx_tmp2 = HX_("note",f2,17,0a,49);
            		}
            		else {
HXLINE( 603)			_hx_tmp2 = HX_("notePixel",34,11,31,00);
            		}
HXDLIN( 603)		this->skinNote = _hx_tmp1->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + _hx_tmp2),null(),null()),true,res,res,null(),null());
HXLINE( 604)		this->skinNote->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 605)		this->skinNote->setGraphicSize(68,null());
HXLINE( 606)		this->skinNote->updateHitbox();
HXLINE( 607)		this->skinNote->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_0afa74a2_21,1),24,true,null(),null());
HXLINE( 608)		this->skinNote->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 609)		if (!(this->onPixel)) {
HXLINE( 609)			this->skinNote->set_antialiasing(false);
            		}
HXLINE( 610)		this->add(this->skinNote);
HXLINE( 612)		int res1;
HXDLIN( 612)		if (!(this->onPixel)) {
HXLINE( 612)			res1 = 160;
            		}
            		else {
HXLINE( 612)			res1 = 17;
            		}
HXLINE( 613)		{
HXLINE( 614)			{
HXLINE( 615)				 ::flixel::FlxSprite newNote =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,230,100,null());
HXDLIN( 615)				::String newNote1;
HXDLIN( 615)				if (!(this->onPixel)) {
HXLINE( 615)					newNote1 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 615)					newNote1 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 615)				 ::flixel::FlxSprite newNote2 = newNote->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote1),null(),null()),true,res1,res1,null(),null());
HXLINE( 616)				newNote2->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 617)				newNote2->setGraphicSize(85,null());
HXLINE( 618)				newNote2->updateHitbox();
HXLINE( 619)				newNote2->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_0afa74a2_22,1),24,true,null(),null());
HXLINE( 620)				newNote2->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 621)				newNote2->ID = 0;
HXLINE( 622)				if (this->onPixel) {
HXLINE( 622)					newNote2->set_antialiasing(false);
            				}
HXLINE( 623)				this->modeNotes->add(newNote2).StaticCast<  ::flixel::FlxSprite >();
            			}
HXLINE( 614)			{
HXLINE( 615)				 ::flixel::FlxSprite newNote3 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,330,100,null());
HXDLIN( 615)				::String newNote4;
HXDLIN( 615)				if (!(this->onPixel)) {
HXLINE( 615)					newNote4 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 615)					newNote4 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 615)				 ::flixel::FlxSprite newNote5 = newNote3->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote4),null(),null()),true,res1,res1,null(),null());
HXLINE( 616)				newNote5->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 617)				newNote5->setGraphicSize(85,null());
HXLINE( 618)				newNote5->updateHitbox();
HXLINE( 619)				newNote5->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_0afa74a2_23,1),24,true,null(),null());
HXLINE( 620)				newNote5->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 621)				newNote5->ID = 1;
HXLINE( 622)				if (this->onPixel) {
HXLINE( 622)					newNote5->set_antialiasing(false);
            				}
HXLINE( 623)				this->modeNotes->add(newNote5).StaticCast<  ::flixel::FlxSprite >();
            			}
HXLINE( 614)			{
HXLINE( 615)				 ::flixel::FlxSprite newNote6 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,430,100,null());
HXDLIN( 615)				::String newNote7;
HXDLIN( 615)				if (!(this->onPixel)) {
HXLINE( 615)					newNote7 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 615)					newNote7 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 615)				 ::flixel::FlxSprite newNote8 = newNote6->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote7),null(),null()),true,res1,res1,null(),null());
HXLINE( 616)				newNote8->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 617)				newNote8->setGraphicSize(85,null());
HXLINE( 618)				newNote8->updateHitbox();
HXLINE( 619)				newNote8->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_0afa74a2_24,1),24,true,null(),null());
HXLINE( 620)				newNote8->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 621)				newNote8->ID = 2;
HXLINE( 622)				if (this->onPixel) {
HXLINE( 622)					newNote8->set_antialiasing(false);
            				}
HXLINE( 623)				this->modeNotes->add(newNote8).StaticCast<  ::flixel::FlxSprite >();
            			}
            		}
HXLINE( 626)		::objects::Note_obj::globalRgbShaders = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 627)		{
HXLINE( 627)			int _g = 0;
HXDLIN( 627)			int _g1 = this->dataArray->length;
HXDLIN( 627)			while((_g < _g1)){
HXLINE( 627)				_g = (_g + 1);
HXDLIN( 627)				int i = (_g - 1);
HXLINE( 629)				::objects::Note_obj::initializeGlobalRGBShader(i);
HXLINE( 630)				 ::objects::StrumNote newNote =  ::objects::StrumNote_obj::__alloc( HX_CTX ,(150 + ((( (Float)(480) ) / ( (Float)(this->dataArray->length) )) * ( (Float)(i) ))),( (Float)(200) ),i,0);
HXLINE( 631)				newNote->useRGBShader = true;
HXLINE( 632)				newNote->setGraphicSize(102,null());
HXLINE( 633)				newNote->updateHitbox();
HXLINE( 634)				newNote->ID = i;
HXLINE( 635)				this->myNotes->add(newNote).StaticCast<  ::objects::StrumNote >();
            			}
            		}
HXLINE( 638)		this->bigNote =  ::objects::Note_obj::__alloc( HX_CTX ,( (Float)(0) ),0,null(),false,true,null());
HXLINE( 639)		this->bigNote->setPosition(250,325);
HXLINE( 640)		this->bigNote->setGraphicSize(250,null());
HXLINE( 641)		this->bigNote->updateHitbox();
HXLINE( 642)		this->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 643)		this->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 644)		{
HXLINE( 644)			int _g2 = 0;
HXDLIN( 644)			int _g3 = ::objects::Note_obj::colArray->length;
HXDLIN( 644)			while((_g2 < _g3)){
HXLINE( 644)				_g2 = (_g2 + 1);
HXDLIN( 644)				int i = (_g2 - 1);
HXLINE( 646)				if (!(this->onPixel)) {
HXLINE( 646)					this->bigNote->animation->addByPrefix((HX_("note",f2,17,0a,49) + i),(::objects::Note_obj::colArray->__get(i) + HX_("0",30,00,00,00)),24,true,null(),null());
            				}
            				else {
HXLINE( 647)					this->bigNote->animation->add((HX_("note",f2,17,0a,49) + i),::Array_obj< int >::__new(1)->init(0,(i + 4)),24,true,null(),null());
            				}
            			}
            		}
HXLINE( 649)		int _hx_tmp3 = (this->members->indexOf(this->myNotes,null()) + 1);
HXDLIN( 649)		this->insert(_hx_tmp3,this->bigNote);
HXLINE( 650)		this->_storedColor = this->getShaderColor();
HXLINE( 651)		::states::PlayState_obj::stageUI = HX_("normal",27,72,69,30);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,spawnNotes,(void))

void NotesSubState_obj::updateNotes( ::Dynamic __o_instant){
            		 ::Dynamic instant = __o_instant;
            		if (::hx::IsNull(__o_instant)) instant = false;
            	HX_GC_STACKFRAME(&_hx_pos_13db6fe15635f7e3_655_updateNotes)
HXLINE( 656)		{
HXLINE( 656)			 ::Dynamic filter = null();
HXDLIN( 656)			 ::flixel::group::FlxTypedGroupIterator note =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->modeNotes->members,filter);
HXDLIN( 656)			while(note->hasNext()){
HXLINE( 656)				 ::flixel::FlxSprite note1 = note->next().StaticCast<  ::flixel::FlxSprite >();
HXLINE( 657)				Float _hx_tmp;
HXDLIN( 657)				if ((this->curSelectedMode == note1->ID)) {
HXLINE( 657)					_hx_tmp = ( (Float)(1) );
            				}
            				else {
HXLINE( 657)					_hx_tmp = ((Float)0.6);
            				}
HXDLIN( 657)				note1->set_alpha(_hx_tmp);
            			}
            		}
HXLINE( 659)		{
HXLINE( 659)			 ::Dynamic filter1 = null();
HXDLIN( 659)			 ::flixel::group::FlxTypedGroupIterator note1 =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->myNotes->members,filter1);
HXDLIN( 659)			while(note1->hasNext()){
HXLINE( 659)				 ::objects::StrumNote note = note1->next().StaticCast<  ::objects::StrumNote >();
HXLINE( 661)				::String newAnim;
HXDLIN( 661)				if ((this->curSelectedNote == note->ID)) {
HXLINE( 661)					newAnim = HX_("confirm",00,9d,39,10);
            				}
            				else {
HXLINE( 661)					newAnim = HX_("pressed",a2,d2,e6,39);
            				}
HXLINE( 662)				Float _hx_tmp;
HXDLIN( 662)				if ((this->curSelectedNote == note->ID)) {
HXLINE( 662)					_hx_tmp = ( (Float)(1) );
            				}
            				else {
HXLINE( 662)					_hx_tmp = ((Float)0.6);
            				}
HXDLIN( 662)				note->set_alpha(_hx_tmp);
HXLINE( 663)				bool _hx_tmp1;
HXDLIN( 663)				if (::hx::IsNotNull( note->animation->_curAnim )) {
HXLINE( 663)					_hx_tmp1 = (note->animation->_curAnim->name != newAnim);
            				}
            				else {
HXLINE( 663)					_hx_tmp1 = true;
            				}
HXDLIN( 663)				if (_hx_tmp1) {
HXLINE( 663)					note->playAnim(newAnim,true);
            				}
HXLINE( 664)				if (( (bool)(instant) )) {
HXLINE( 664)					note->animation->_curAnim->finish();
            				}
            			}
            		}
HXLINE( 666)		this->bigNote->animation->play((HX_("note",f2,17,0a,49) + this->curSelectedNote),true,null(),null());
HXLINE( 667)		this->updateColors(null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,updateNotes,(void))

void NotesSubState_obj::updateColors( ::Dynamic specific){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_671_updateColors)
HXLINE( 672)		int color = this->getShaderColor();
HXLINE( 673)		int wheelColor;
HXDLIN( 673)		if (::hx::IsNull( specific )) {
HXLINE( 673)			wheelColor = this->getShaderColor();
            		}
            		else {
HXLINE( 673)			wheelColor = ( (int)(specific) );
            		}
HXLINE( 674)		 ::objects::Alphabet _hx_tmp = this->alphabetR;
HXDLIN( 674)		_hx_tmp->set_text(::Std_obj::string(((color >> 16) & 255)));
HXLINE( 675)		 ::objects::Alphabet _hx_tmp1 = this->alphabetG;
HXDLIN( 675)		_hx_tmp1->set_text(::Std_obj::string(((color >> 8) & 255)));
HXLINE( 676)		 ::objects::Alphabet _hx_tmp2 = this->alphabetB;
HXDLIN( 676)		_hx_tmp2->set_text(::Std_obj::string((color & 255)));
HXLINE( 677)		 ::objects::Alphabet _hx_tmp3 = this->alphabetHex;
HXDLIN( 677)		::String _hx_tmp4 = (HX_("",00,00,00,00) + ::StringTools_obj::hex(((color >> 16) & 255),2));
HXDLIN( 677)		::String _hx_tmp5 = (_hx_tmp4 + ::StringTools_obj::hex(((color >> 8) & 255),2));
HXDLIN( 677)		_hx_tmp3->set_text((_hx_tmp5 + ::StringTools_obj::hex((color & 255),2)));
HXLINE( 678)		{
HXLINE( 678)			int _g = 0;
HXDLIN( 678)			::Array< ::Dynamic> _g1 = this->alphabetHex->letters;
HXDLIN( 678)			while((_g < _g1->length)){
HXLINE( 678)				 ::objects::AlphaCharacter letter = _g1->__get(_g).StaticCast<  ::objects::AlphaCharacter >();
HXDLIN( 678)				_g = (_g + 1);
HXDLIN( 678)				letter->set_color(color);
            			}
            		}
HXLINE( 680)		 ::flixel::FlxSprite _hx_tmp6 = this->colorWheel;
HXDLIN( 680)		_hx_tmp6->set_color(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(( (Float)(0) ),( (Float)(0) ),::Math_obj::max((( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((color & 255)) ) / ( (Float)(255) )))),null()));
HXLINE( 681)		 ::flixel::FlxSprite _hx_tmp7 = this->colorWheelSelector;
HXDLIN( 681)		Float _hx_tmp8 = this->colorWheel->x;
HXDLIN( 681)		Float _hx_tmp9 = (_hx_tmp8 + (this->colorWheel->get_width() / ( (Float)(2) )));
HXDLIN( 681)		Float _hx_tmp10 = this->colorWheel->y;
HXDLIN( 681)		_hx_tmp7->setPosition(_hx_tmp9,(_hx_tmp10 + (this->colorWheel->get_height() / ( (Float)(2) ))));
HXLINE( 682)		if ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) != 0)) {
HXLINE( 684)			Float hueWrap = ::flixel::util::_FlxColor::FlxColor_Impl__obj::get_hue(wheelColor);
HXDLIN( 684)			Float hueWrap1 = ((hueWrap * ::Math_obj::PI) / ( (Float)(180) ));
HXLINE( 685)			 ::flixel::FlxSprite fh = this->colorWheelSelector;
HXDLIN( 685)			Float fh1 = fh->x;
HXDLIN( 685)			Float _hx_tmp = ::Math_obj::sin(hueWrap1);
HXDLIN( 685)			Float _hx_tmp1 = ((_hx_tmp * this->colorWheel->get_width()) / ( (Float)(2) ));
HXDLIN( 685)			fh->set_x((fh1 + (_hx_tmp1 * ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))))));
HXLINE( 686)			 ::flixel::FlxSprite fh2 = this->colorWheelSelector;
HXDLIN( 686)			Float fh3 = fh2->y;
HXDLIN( 686)			Float _hx_tmp2 = ::Math_obj::cos(hueWrap1);
HXDLIN( 686)			Float _hx_tmp3 = ((_hx_tmp2 * this->colorWheel->get_height()) / ( (Float)(2) ));
HXDLIN( 686)			fh2->set_y((fh3 - (_hx_tmp3 * ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))))));
            		}
HXLINE( 688)		 ::flixel::FlxSprite _hx_tmp11 = this->colorGradientSelector;
HXDLIN( 688)		Float _hx_tmp12 = this->colorGradient->y;
HXDLIN( 688)		Float _hx_tmp13 = this->colorGradient->get_height();
HXDLIN( 688)		_hx_tmp11->set_y((_hx_tmp12 + (_hx_tmp13 * (( (Float)(1) ) - ::Math_obj::max((( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((color & 255)) ) / ( (Float)(255) ))))))));
HXLINE( 690)		 ::shaders::RGBShaderReference strumRGB = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 691)		switch((int)(this->curSelectedMode)){
            			case (int)0: {
HXLINE( 694)				 ::shaders::RGBPalette _hx_tmp = this->getShader();
HXDLIN( 694)				_hx_tmp->set_r(strumRGB->set_r(color));
            			}
            			break;
            			case (int)1: {
HXLINE( 696)				 ::shaders::RGBPalette _hx_tmp = this->getShader();
HXDLIN( 696)				_hx_tmp->set_g(strumRGB->set_g(color));
            			}
            			break;
            			case (int)2: {
HXLINE( 698)				 ::shaders::RGBPalette _hx_tmp = this->getShader();
HXDLIN( 698)				_hx_tmp->set_b(strumRGB->set_b(color));
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,updateColors,(void))

void NotesSubState_obj::setShaderColor(int value){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_702_setShaderColor)
HXDLIN( 702)		this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[this->curSelectedMode] = value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesSubState_obj,setShaderColor,(void))

int NotesSubState_obj::getShaderColor(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_703_getShaderColor)
HXDLIN( 703)		return this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,getShaderColor,return )

 ::shaders::RGBPalette NotesSubState_obj::getShader(){
            	HX_STACKFRAME(&_hx_pos_13db6fe15635f7e3_704_getShader)
HXDLIN( 704)		return ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesSubState_obj,getShader,return )


::hx::ObjectPtr< NotesSubState_obj > NotesSubState_obj::__new() {
	::hx::ObjectPtr< NotesSubState_obj > __this = new NotesSubState_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< NotesSubState_obj > NotesSubState_obj::__alloc(::hx::Ctx *_hx_ctx) {
	NotesSubState_obj *__this = (NotesSubState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NotesSubState_obj), true, "options.NotesSubState"));
	*(void **)__this = NotesSubState_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

NotesSubState_obj::NotesSubState_obj()
{
}

void NotesSubState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(NotesSubState);
	HX_MARK_MEMBER_NAME(onModeColumn,"onModeColumn");
	HX_MARK_MEMBER_NAME(curSelectedMode,"curSelectedMode");
	HX_MARK_MEMBER_NAME(curSelectedNote,"curSelectedNote");
	HX_MARK_MEMBER_NAME(onPixel,"onPixel");
	HX_MARK_MEMBER_NAME(dataArray,"dataArray");
	HX_MARK_MEMBER_NAME(hexTypeLine,"hexTypeLine");
	HX_MARK_MEMBER_NAME(hexTypeNum,"hexTypeNum");
	HX_MARK_MEMBER_NAME(hexTypeVisibleTimer,"hexTypeVisibleTimer");
	HX_MARK_MEMBER_NAME(copyButton,"copyButton");
	HX_MARK_MEMBER_NAME(pasteButton,"pasteButton");
	HX_MARK_MEMBER_NAME(colorGradient,"colorGradient");
	HX_MARK_MEMBER_NAME(colorGradientSelector,"colorGradientSelector");
	HX_MARK_MEMBER_NAME(colorPalette,"colorPalette");
	HX_MARK_MEMBER_NAME(colorWheel,"colorWheel");
	HX_MARK_MEMBER_NAME(colorWheelSelector,"colorWheelSelector");
	HX_MARK_MEMBER_NAME(alphabetR,"alphabetR");
	HX_MARK_MEMBER_NAME(alphabetG,"alphabetG");
	HX_MARK_MEMBER_NAME(alphabetB,"alphabetB");
	HX_MARK_MEMBER_NAME(alphabetHex,"alphabetHex");
	HX_MARK_MEMBER_NAME(modeBG,"modeBG");
	HX_MARK_MEMBER_NAME(notesBG,"notesBG");
	HX_MARK_MEMBER_NAME(controllerPointer,"controllerPointer");
	HX_MARK_MEMBER_NAME(_lastControllerMode,"_lastControllerMode");
	HX_MARK_MEMBER_NAME(tipTxt,"tipTxt");
	HX_MARK_MEMBER_NAME(_storedColor,"_storedColor");
	HX_MARK_MEMBER_NAME(changingNote,"changingNote");
	HX_MARK_MEMBER_NAME(holdingOnObj,"holdingOnObj");
	HX_MARK_MEMBER_NAME(allowedTypeKeys,"allowedTypeKeys");
	HX_MARK_MEMBER_NAME(skinNote,"skinNote");
	HX_MARK_MEMBER_NAME(modeNotes,"modeNotes");
	HX_MARK_MEMBER_NAME(myNotes,"myNotes");
	HX_MARK_MEMBER_NAME(bigNote,"bigNote");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void NotesSubState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(onModeColumn,"onModeColumn");
	HX_VISIT_MEMBER_NAME(curSelectedMode,"curSelectedMode");
	HX_VISIT_MEMBER_NAME(curSelectedNote,"curSelectedNote");
	HX_VISIT_MEMBER_NAME(onPixel,"onPixel");
	HX_VISIT_MEMBER_NAME(dataArray,"dataArray");
	HX_VISIT_MEMBER_NAME(hexTypeLine,"hexTypeLine");
	HX_VISIT_MEMBER_NAME(hexTypeNum,"hexTypeNum");
	HX_VISIT_MEMBER_NAME(hexTypeVisibleTimer,"hexTypeVisibleTimer");
	HX_VISIT_MEMBER_NAME(copyButton,"copyButton");
	HX_VISIT_MEMBER_NAME(pasteButton,"pasteButton");
	HX_VISIT_MEMBER_NAME(colorGradient,"colorGradient");
	HX_VISIT_MEMBER_NAME(colorGradientSelector,"colorGradientSelector");
	HX_VISIT_MEMBER_NAME(colorPalette,"colorPalette");
	HX_VISIT_MEMBER_NAME(colorWheel,"colorWheel");
	HX_VISIT_MEMBER_NAME(colorWheelSelector,"colorWheelSelector");
	HX_VISIT_MEMBER_NAME(alphabetR,"alphabetR");
	HX_VISIT_MEMBER_NAME(alphabetG,"alphabetG");
	HX_VISIT_MEMBER_NAME(alphabetB,"alphabetB");
	HX_VISIT_MEMBER_NAME(alphabetHex,"alphabetHex");
	HX_VISIT_MEMBER_NAME(modeBG,"modeBG");
	HX_VISIT_MEMBER_NAME(notesBG,"notesBG");
	HX_VISIT_MEMBER_NAME(controllerPointer,"controllerPointer");
	HX_VISIT_MEMBER_NAME(_lastControllerMode,"_lastControllerMode");
	HX_VISIT_MEMBER_NAME(tipTxt,"tipTxt");
	HX_VISIT_MEMBER_NAME(_storedColor,"_storedColor");
	HX_VISIT_MEMBER_NAME(changingNote,"changingNote");
	HX_VISIT_MEMBER_NAME(holdingOnObj,"holdingOnObj");
	HX_VISIT_MEMBER_NAME(allowedTypeKeys,"allowedTypeKeys");
	HX_VISIT_MEMBER_NAME(skinNote,"skinNote");
	HX_VISIT_MEMBER_NAME(modeNotes,"modeNotes");
	HX_VISIT_MEMBER_NAME(myNotes,"myNotes");
	HX_VISIT_MEMBER_NAME(bigNote,"bigNote");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val NotesSubState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"modeBG") ) { return ::hx::Val( modeBG ); }
		if (HX_FIELD_EQ(inName,"tipTxt") ) { return ::hx::Val( tipTxt ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onPixel") ) { return ::hx::Val( onPixel ); }
		if (HX_FIELD_EQ(inName,"notesBG") ) { return ::hx::Val( notesBG ); }
		if (HX_FIELD_EQ(inName,"myNotes") ) { return ::hx::Val( myNotes ); }
		if (HX_FIELD_EQ(inName,"bigNote") ) { return ::hx::Val( bigNote ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pointerX") ) { return ::hx::Val( pointerX_dyn() ); }
		if (HX_FIELD_EQ(inName,"pointerY") ) { return ::hx::Val( pointerY_dyn() ); }
		if (HX_FIELD_EQ(inName,"skinNote") ) { return ::hx::Val( skinNote ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dataArray") ) { return ::hx::Val( dataArray ); }
		if (HX_FIELD_EQ(inName,"alphabetR") ) { return ::hx::Val( alphabetR ); }
		if (HX_FIELD_EQ(inName,"alphabetG") ) { return ::hx::Val( alphabetG ); }
		if (HX_FIELD_EQ(inName,"alphabetB") ) { return ::hx::Val( alphabetB ); }
		if (HX_FIELD_EQ(inName,"updateTip") ) { return ::hx::Val( updateTip_dyn() ); }
		if (HX_FIELD_EQ(inName,"modeNotes") ) { return ::hx::Val( modeNotes ); }
		if (HX_FIELD_EQ(inName,"getShader") ) { return ::hx::Val( getShader_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hexTypeNum") ) { return ::hx::Val( hexTypeNum ); }
		if (HX_FIELD_EQ(inName,"copyButton") ) { return ::hx::Val( copyButton ); }
		if (HX_FIELD_EQ(inName,"colorWheel") ) { return ::hx::Val( colorWheel ); }
		if (HX_FIELD_EQ(inName,"spawnNotes") ) { return ::hx::Val( spawnNotes_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"hexTypeLine") ) { return ::hx::Val( hexTypeLine ); }
		if (HX_FIELD_EQ(inName,"pasteButton") ) { return ::hx::Val( pasteButton ); }
		if (HX_FIELD_EQ(inName,"alphabetHex") ) { return ::hx::Val( alphabetHex ); }
		if (HX_FIELD_EQ(inName,"updateNotes") ) { return ::hx::Val( updateNotes_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onModeColumn") ) { return ::hx::Val( onModeColumn ); }
		if (HX_FIELD_EQ(inName,"colorPalette") ) { return ::hx::Val( colorPalette ); }
		if (HX_FIELD_EQ(inName,"_storedColor") ) { return ::hx::Val( _storedColor ); }
		if (HX_FIELD_EQ(inName,"changingNote") ) { return ::hx::Val( changingNote ); }
		if (HX_FIELD_EQ(inName,"holdingOnObj") ) { return ::hx::Val( holdingOnObj ); }
		if (HX_FIELD_EQ(inName,"updateColors") ) { return ::hx::Val( updateColors_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorGradient") ) { return ::hx::Val( colorGradient ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setShaderColor") ) { return ::hx::Val( setShaderColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"getShaderColor") ) { return ::hx::Val( getShaderColor_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curSelectedMode") ) { return ::hx::Val( curSelectedMode ); }
		if (HX_FIELD_EQ(inName,"curSelectedNote") ) { return ::hx::Val( curSelectedNote ); }
		if (HX_FIELD_EQ(inName,"allowedTypeKeys") ) { return ::hx::Val( allowedTypeKeys ); }
		if (HX_FIELD_EQ(inName,"pointerOverlaps") ) { return ::hx::Val( pointerOverlaps_dyn() ); }
		if (HX_FIELD_EQ(inName,"pointerFlxPoint") ) { return ::hx::Val( pointerFlxPoint_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"controllerPointer") ) { return ::hx::Val( controllerPointer ); }
		if (HX_FIELD_EQ(inName,"centerHexTypeLine") ) { return ::hx::Val( centerHexTypeLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeColorAlphabet") ) { return ::hx::Val( makeColorAlphabet_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWheelSelector") ) { return ::hx::Val( colorWheelSelector ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"hexTypeVisibleTimer") ) { return ::hx::Val( hexTypeVisibleTimer ); }
		if (HX_FIELD_EQ(inName,"_lastControllerMode") ) { return ::hx::Val( _lastControllerMode ); }
		if (HX_FIELD_EQ(inName,"changeSelectionMode") ) { return ::hx::Val( changeSelectionMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"changeSelectionNote") ) { return ::hx::Val( changeSelectionNote_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"colorGradientSelector") ) { return ::hx::Val( colorGradientSelector ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val NotesSubState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"modeBG") ) { modeBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tipTxt") ) { tipTxt=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onPixel") ) { onPixel=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"notesBG") ) { notesBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"myNotes") ) { myNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bigNote") ) { bigNote=inValue.Cast<  ::objects::Note >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"skinNote") ) { skinNote=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dataArray") ) { dataArray=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetR") ) { alphabetR=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetG") ) { alphabetG=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetB") ) { alphabetB=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"modeNotes") ) { modeNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hexTypeNum") ) { hexTypeNum=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"copyButton") ) { copyButton=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorWheel") ) { colorWheel=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"hexTypeLine") ) { hexTypeLine=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pasteButton") ) { pasteButton=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetHex") ) { alphabetHex=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onModeColumn") ) { onModeColumn=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorPalette") ) { colorPalette=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_storedColor") ) { _storedColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"changingNote") ) { changingNote=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingOnObj") ) { holdingOnObj=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorGradient") ) { colorGradient=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curSelectedMode") ) { curSelectedMode=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curSelectedNote") ) { curSelectedNote=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"allowedTypeKeys") ) { allowedTypeKeys=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"controllerPointer") ) { controllerPointer=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWheelSelector") ) { colorWheelSelector=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"hexTypeVisibleTimer") ) { hexTypeVisibleTimer=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_lastControllerMode") ) { _lastControllerMode=inValue.Cast< bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"colorGradientSelector") ) { colorGradientSelector=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void NotesSubState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("onModeColumn",98,64,71,e9));
	outFields->push(HX_("curSelectedMode",fe,04,4b,47));
	outFields->push(HX_("curSelectedNote",8d,49,f4,47));
	outFields->push(HX_("onPixel",e7,64,e1,58));
	outFields->push(HX_("dataArray",0f,ef,7e,6b));
	outFields->push(HX_("hexTypeLine",c9,ed,15,a7));
	outFields->push(HX_("hexTypeNum",11,5a,3d,ed));
	outFields->push(HX_("hexTypeVisibleTimer",c8,0c,57,76));
	outFields->push(HX_("copyButton",87,c7,a4,8f));
	outFields->push(HX_("pasteButton",a5,e9,40,61));
	outFields->push(HX_("colorGradient",73,02,02,2d));
	outFields->push(HX_("colorGradientSelector",b2,1c,65,2f));
	outFields->push(HX_("colorPalette",58,8b,ba,95));
	outFields->push(HX_("colorWheel",38,4c,26,ee));
	outFields->push(HX_("colorWheelSelector",77,33,40,df));
	outFields->push(HX_("alphabetR",3f,a0,34,f0));
	outFields->push(HX_("alphabetG",34,a0,34,f0));
	outFields->push(HX_("alphabetB",2f,a0,34,f0));
	outFields->push(HX_("alphabetHex",e8,2f,c5,de));
	outFields->push(HX_("modeBG",e8,eb,c6,c0));
	outFields->push(HX_("notesBG",46,68,6b,4d));
	outFields->push(HX_("controllerPointer",81,db,f4,1b));
	outFields->push(HX_("_lastControllerMode",34,63,09,11));
	outFields->push(HX_("tipTxt",d5,cf,c0,20));
	outFields->push(HX_("_storedColor",01,57,07,9c));
	outFields->push(HX_("changingNote",3f,d5,59,d6));
	outFields->push(HX_("holdingOnObj",15,34,32,64));
	outFields->push(HX_("allowedTypeKeys",16,fb,41,3c));
	outFields->push(HX_("skinNote",0f,dd,91,98));
	outFields->push(HX_("modeNotes",de,51,0f,71));
	outFields->push(HX_("myNotes",35,85,ca,48));
	outFields->push(HX_("bigNote",d2,5c,d9,68));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo NotesSubState_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,onModeColumn),HX_("onModeColumn",98,64,71,e9)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,curSelectedMode),HX_("curSelectedMode",fe,04,4b,47)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,curSelectedNote),HX_("curSelectedNote",8d,49,f4,47)},
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,onPixel),HX_("onPixel",e7,64,e1,58)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(NotesSubState_obj,dataArray),HX_("dataArray",0f,ef,7e,6b)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,hexTypeLine),HX_("hexTypeLine",c9,ed,15,a7)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,hexTypeNum),HX_("hexTypeNum",11,5a,3d,ed)},
	{::hx::fsFloat,(int)offsetof(NotesSubState_obj,hexTypeVisibleTimer),HX_("hexTypeVisibleTimer",c8,0c,57,76)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,copyButton),HX_("copyButton",87,c7,a4,8f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,pasteButton),HX_("pasteButton",a5,e9,40,61)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorGradient),HX_("colorGradient",73,02,02,2d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorGradientSelector),HX_("colorGradientSelector",b2,1c,65,2f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorPalette),HX_("colorPalette",58,8b,ba,95)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorWheel),HX_("colorWheel",38,4c,26,ee)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,colorWheelSelector),HX_("colorWheelSelector",77,33,40,df)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetR),HX_("alphabetR",3f,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetG),HX_("alphabetG",34,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetB),HX_("alphabetB",2f,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesSubState_obj,alphabetHex),HX_("alphabetHex",e8,2f,c5,de)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,modeBG),HX_("modeBG",e8,eb,c6,c0)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,notesBG),HX_("notesBG",46,68,6b,4d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,controllerPointer),HX_("controllerPointer",81,db,f4,1b)},
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,_lastControllerMode),HX_("_lastControllerMode",34,63,09,11)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(NotesSubState_obj,tipTxt),HX_("tipTxt",d5,cf,c0,20)},
	{::hx::fsInt,(int)offsetof(NotesSubState_obj,_storedColor),HX_("_storedColor",01,57,07,9c)},
	{::hx::fsBool,(int)offsetof(NotesSubState_obj,changingNote),HX_("changingNote",3f,d5,59,d6)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,holdingOnObj),HX_("holdingOnObj",15,34,32,64)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(NotesSubState_obj,allowedTypeKeys),HX_("allowedTypeKeys",16,fb,41,3c)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesSubState_obj,skinNote),HX_("skinNote",0f,dd,91,98)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(NotesSubState_obj,modeNotes),HX_("modeNotes",de,51,0f,71)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(NotesSubState_obj,myNotes),HX_("myNotes",35,85,ca,48)},
	{::hx::fsObject /*  ::objects::Note */ ,(int)offsetof(NotesSubState_obj,bigNote),HX_("bigNote",d2,5c,d9,68)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *NotesSubState_obj_sStaticStorageInfo = 0;
#endif

static ::String NotesSubState_obj_sMemberFields[] = {
	HX_("onModeColumn",98,64,71,e9),
	HX_("curSelectedMode",fe,04,4b,47),
	HX_("curSelectedNote",8d,49,f4,47),
	HX_("onPixel",e7,64,e1,58),
	HX_("dataArray",0f,ef,7e,6b),
	HX_("hexTypeLine",c9,ed,15,a7),
	HX_("hexTypeNum",11,5a,3d,ed),
	HX_("hexTypeVisibleTimer",c8,0c,57,76),
	HX_("copyButton",87,c7,a4,8f),
	HX_("pasteButton",a5,e9,40,61),
	HX_("colorGradient",73,02,02,2d),
	HX_("colorGradientSelector",b2,1c,65,2f),
	HX_("colorPalette",58,8b,ba,95),
	HX_("colorWheel",38,4c,26,ee),
	HX_("colorWheelSelector",77,33,40,df),
	HX_("alphabetR",3f,a0,34,f0),
	HX_("alphabetG",34,a0,34,f0),
	HX_("alphabetB",2f,a0,34,f0),
	HX_("alphabetHex",e8,2f,c5,de),
	HX_("modeBG",e8,eb,c6,c0),
	HX_("notesBG",46,68,6b,4d),
	HX_("controllerPointer",81,db,f4,1b),
	HX_("_lastControllerMode",34,63,09,11),
	HX_("tipTxt",d5,cf,c0,20),
	HX_("updateTip",d2,3e,e5,82),
	HX_("_storedColor",01,57,07,9c),
	HX_("changingNote",3f,d5,59,d6),
	HX_("holdingOnObj",15,34,32,64),
	HX_("allowedTypeKeys",16,fb,41,3c),
	HX_("update",09,86,05,87),
	HX_("pointerOverlaps",e9,d4,f8,c3),
	HX_("pointerX",fb,e4,66,ac),
	HX_("pointerY",fc,e4,66,ac),
	HX_("pointerFlxPoint",5b,04,86,28),
	HX_("centerHexTypeLine",f4,b5,6b,cc),
	HX_("changeSelectionMode",3f,a6,f0,a1),
	HX_("changeSelectionNote",ce,ea,99,a2),
	HX_("makeColorAlphabet",68,3e,89,ba),
	HX_("skinNote",0f,dd,91,98),
	HX_("modeNotes",de,51,0f,71),
	HX_("myNotes",35,85,ca,48),
	HX_("bigNote",d2,5c,d9,68),
	HX_("spawnNotes",06,38,e3,d9),
	HX_("updateNotes",78,45,63,85),
	HX_("updateColors",99,6c,4a,c6),
	HX_("setShaderColor",7c,57,47,c9),
	HX_("getShaderColor",08,6f,27,a9),
	HX_("getShader",5b,48,77,99),
	::String(null()) };

::hx::Class NotesSubState_obj::__mClass;

void NotesSubState_obj::__register()
{
	NotesSubState_obj _hx_dummy;
	NotesSubState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("options.NotesSubState",a2,74,fa,0a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NotesSubState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NotesSubState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NotesSubState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NotesSubState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace options
